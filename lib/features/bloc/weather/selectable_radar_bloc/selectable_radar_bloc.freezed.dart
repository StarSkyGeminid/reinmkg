// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'selectable_radar_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SelectableRadarEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(RadarEntity entity) setRadar,
    required TResult Function(RadarType type) setRadarType,
    required TResult Function() play,
    required TResult Function(int index) sliderChanged,
    required TResult Function() previous,
    required TResult Function() next,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(RadarEntity entity)? setRadar,
    TResult? Function(RadarType type)? setRadarType,
    TResult? Function()? play,
    TResult? Function(int index)? sliderChanged,
    TResult? Function()? previous,
    TResult? Function()? next,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(RadarEntity entity)? setRadar,
    TResult Function(RadarType type)? setRadarType,
    TResult Function()? play,
    TResult Function(int index)? sliderChanged,
    TResult Function()? previous,
    TResult Function()? next,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_SetRadar value) setRadar,
    required TResult Function(_RadarType value) setRadarType,
    required TResult Function(_Play value) play,
    required TResult Function(_SliderChanged value) sliderChanged,
    required TResult Function(_Previous value) previous,
    required TResult Function(_Next value) next,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_SetRadar value)? setRadar,
    TResult? Function(_RadarType value)? setRadarType,
    TResult? Function(_Play value)? play,
    TResult? Function(_SliderChanged value)? sliderChanged,
    TResult? Function(_Previous value)? previous,
    TResult? Function(_Next value)? next,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_SetRadar value)? setRadar,
    TResult Function(_RadarType value)? setRadarType,
    TResult Function(_Play value)? play,
    TResult Function(_SliderChanged value)? sliderChanged,
    TResult Function(_Previous value)? previous,
    TResult Function(_Next value)? next,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SelectableRadarEventCopyWith<$Res> {
  factory $SelectableRadarEventCopyWith(SelectableRadarEvent value,
          $Res Function(SelectableRadarEvent) then) =
      _$SelectableRadarEventCopyWithImpl<$Res, SelectableRadarEvent>;
}

/// @nodoc
class _$SelectableRadarEventCopyWithImpl<$Res,
        $Val extends SelectableRadarEvent>
    implements $SelectableRadarEventCopyWith<$Res> {
  _$SelectableRadarEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SelectableRadarEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$StartedImplCopyWith<$Res> {
  factory _$$StartedImplCopyWith(
          _$StartedImpl value, $Res Function(_$StartedImpl) then) =
      __$$StartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartedImplCopyWithImpl<$Res>
    extends _$SelectableRadarEventCopyWithImpl<$Res, _$StartedImpl>
    implements _$$StartedImplCopyWith<$Res> {
  __$$StartedImplCopyWithImpl(
      _$StartedImpl _value, $Res Function(_$StartedImpl) _then)
      : super(_value, _then);

  /// Create a copy of SelectableRadarEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$StartedImpl implements _Started {
  const _$StartedImpl();

  @override
  String toString() {
    return 'SelectableRadarEvent.started()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(RadarEntity entity) setRadar,
    required TResult Function(RadarType type) setRadarType,
    required TResult Function() play,
    required TResult Function(int index) sliderChanged,
    required TResult Function() previous,
    required TResult Function() next,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(RadarEntity entity)? setRadar,
    TResult? Function(RadarType type)? setRadarType,
    TResult? Function()? play,
    TResult? Function(int index)? sliderChanged,
    TResult? Function()? previous,
    TResult? Function()? next,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(RadarEntity entity)? setRadar,
    TResult Function(RadarType type)? setRadarType,
    TResult Function()? play,
    TResult Function(int index)? sliderChanged,
    TResult Function()? previous,
    TResult Function()? next,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_SetRadar value) setRadar,
    required TResult Function(_RadarType value) setRadarType,
    required TResult Function(_Play value) play,
    required TResult Function(_SliderChanged value) sliderChanged,
    required TResult Function(_Previous value) previous,
    required TResult Function(_Next value) next,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_SetRadar value)? setRadar,
    TResult? Function(_RadarType value)? setRadarType,
    TResult? Function(_Play value)? play,
    TResult? Function(_SliderChanged value)? sliderChanged,
    TResult? Function(_Previous value)? previous,
    TResult? Function(_Next value)? next,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_SetRadar value)? setRadar,
    TResult Function(_RadarType value)? setRadarType,
    TResult Function(_Play value)? play,
    TResult Function(_SliderChanged value)? sliderChanged,
    TResult Function(_Previous value)? previous,
    TResult Function(_Next value)? next,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _Started implements SelectableRadarEvent {
  const factory _Started() = _$StartedImpl;
}

/// @nodoc
abstract class _$$SetRadarImplCopyWith<$Res> {
  factory _$$SetRadarImplCopyWith(
          _$SetRadarImpl value, $Res Function(_$SetRadarImpl) then) =
      __$$SetRadarImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RadarEntity entity});
}

/// @nodoc
class __$$SetRadarImplCopyWithImpl<$Res>
    extends _$SelectableRadarEventCopyWithImpl<$Res, _$SetRadarImpl>
    implements _$$SetRadarImplCopyWith<$Res> {
  __$$SetRadarImplCopyWithImpl(
      _$SetRadarImpl _value, $Res Function(_$SetRadarImpl) _then)
      : super(_value, _then);

  /// Create a copy of SelectableRadarEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? entity = null,
  }) {
    return _then(_$SetRadarImpl(
      null == entity
          ? _value.entity
          : entity // ignore: cast_nullable_to_non_nullable
              as RadarEntity,
    ));
  }
}

/// @nodoc

class _$SetRadarImpl implements _SetRadar {
  const _$SetRadarImpl(this.entity);

  @override
  final RadarEntity entity;

  @override
  String toString() {
    return 'SelectableRadarEvent.setRadar(entity: $entity)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SetRadarImpl &&
            (identical(other.entity, entity) || other.entity == entity));
  }

  @override
  int get hashCode => Object.hash(runtimeType, entity);

  /// Create a copy of SelectableRadarEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SetRadarImplCopyWith<_$SetRadarImpl> get copyWith =>
      __$$SetRadarImplCopyWithImpl<_$SetRadarImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(RadarEntity entity) setRadar,
    required TResult Function(RadarType type) setRadarType,
    required TResult Function() play,
    required TResult Function(int index) sliderChanged,
    required TResult Function() previous,
    required TResult Function() next,
  }) {
    return setRadar(entity);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(RadarEntity entity)? setRadar,
    TResult? Function(RadarType type)? setRadarType,
    TResult? Function()? play,
    TResult? Function(int index)? sliderChanged,
    TResult? Function()? previous,
    TResult? Function()? next,
  }) {
    return setRadar?.call(entity);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(RadarEntity entity)? setRadar,
    TResult Function(RadarType type)? setRadarType,
    TResult Function()? play,
    TResult Function(int index)? sliderChanged,
    TResult Function()? previous,
    TResult Function()? next,
    required TResult orElse(),
  }) {
    if (setRadar != null) {
      return setRadar(entity);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_SetRadar value) setRadar,
    required TResult Function(_RadarType value) setRadarType,
    required TResult Function(_Play value) play,
    required TResult Function(_SliderChanged value) sliderChanged,
    required TResult Function(_Previous value) previous,
    required TResult Function(_Next value) next,
  }) {
    return setRadar(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_SetRadar value)? setRadar,
    TResult? Function(_RadarType value)? setRadarType,
    TResult? Function(_Play value)? play,
    TResult? Function(_SliderChanged value)? sliderChanged,
    TResult? Function(_Previous value)? previous,
    TResult? Function(_Next value)? next,
  }) {
    return setRadar?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_SetRadar value)? setRadar,
    TResult Function(_RadarType value)? setRadarType,
    TResult Function(_Play value)? play,
    TResult Function(_SliderChanged value)? sliderChanged,
    TResult Function(_Previous value)? previous,
    TResult Function(_Next value)? next,
    required TResult orElse(),
  }) {
    if (setRadar != null) {
      return setRadar(this);
    }
    return orElse();
  }
}

abstract class _SetRadar implements SelectableRadarEvent {
  const factory _SetRadar(final RadarEntity entity) = _$SetRadarImpl;

  RadarEntity get entity;

  /// Create a copy of SelectableRadarEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SetRadarImplCopyWith<_$SetRadarImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RadarTypeImplCopyWith<$Res> {
  factory _$$RadarTypeImplCopyWith(
          _$RadarTypeImpl value, $Res Function(_$RadarTypeImpl) then) =
      __$$RadarTypeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RadarType type});
}

/// @nodoc
class __$$RadarTypeImplCopyWithImpl<$Res>
    extends _$SelectableRadarEventCopyWithImpl<$Res, _$RadarTypeImpl>
    implements _$$RadarTypeImplCopyWith<$Res> {
  __$$RadarTypeImplCopyWithImpl(
      _$RadarTypeImpl _value, $Res Function(_$RadarTypeImpl) _then)
      : super(_value, _then);

  /// Create a copy of SelectableRadarEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$RadarTypeImpl(
      null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RadarType,
    ));
  }
}

/// @nodoc

class _$RadarTypeImpl implements _RadarType {
  const _$RadarTypeImpl(this.type);

  @override
  final RadarType type;

  @override
  String toString() {
    return 'SelectableRadarEvent.setRadarType(type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RadarTypeImpl &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(runtimeType, type);

  /// Create a copy of SelectableRadarEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RadarTypeImplCopyWith<_$RadarTypeImpl> get copyWith =>
      __$$RadarTypeImplCopyWithImpl<_$RadarTypeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(RadarEntity entity) setRadar,
    required TResult Function(RadarType type) setRadarType,
    required TResult Function() play,
    required TResult Function(int index) sliderChanged,
    required TResult Function() previous,
    required TResult Function() next,
  }) {
    return setRadarType(type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(RadarEntity entity)? setRadar,
    TResult? Function(RadarType type)? setRadarType,
    TResult? Function()? play,
    TResult? Function(int index)? sliderChanged,
    TResult? Function()? previous,
    TResult? Function()? next,
  }) {
    return setRadarType?.call(type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(RadarEntity entity)? setRadar,
    TResult Function(RadarType type)? setRadarType,
    TResult Function()? play,
    TResult Function(int index)? sliderChanged,
    TResult Function()? previous,
    TResult Function()? next,
    required TResult orElse(),
  }) {
    if (setRadarType != null) {
      return setRadarType(type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_SetRadar value) setRadar,
    required TResult Function(_RadarType value) setRadarType,
    required TResult Function(_Play value) play,
    required TResult Function(_SliderChanged value) sliderChanged,
    required TResult Function(_Previous value) previous,
    required TResult Function(_Next value) next,
  }) {
    return setRadarType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_SetRadar value)? setRadar,
    TResult? Function(_RadarType value)? setRadarType,
    TResult? Function(_Play value)? play,
    TResult? Function(_SliderChanged value)? sliderChanged,
    TResult? Function(_Previous value)? previous,
    TResult? Function(_Next value)? next,
  }) {
    return setRadarType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_SetRadar value)? setRadar,
    TResult Function(_RadarType value)? setRadarType,
    TResult Function(_Play value)? play,
    TResult Function(_SliderChanged value)? sliderChanged,
    TResult Function(_Previous value)? previous,
    TResult Function(_Next value)? next,
    required TResult orElse(),
  }) {
    if (setRadarType != null) {
      return setRadarType(this);
    }
    return orElse();
  }
}

abstract class _RadarType implements SelectableRadarEvent {
  const factory _RadarType(final RadarType type) = _$RadarTypeImpl;

  RadarType get type;

  /// Create a copy of SelectableRadarEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RadarTypeImplCopyWith<_$RadarTypeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PlayImplCopyWith<$Res> {
  factory _$$PlayImplCopyWith(
          _$PlayImpl value, $Res Function(_$PlayImpl) then) =
      __$$PlayImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PlayImplCopyWithImpl<$Res>
    extends _$SelectableRadarEventCopyWithImpl<$Res, _$PlayImpl>
    implements _$$PlayImplCopyWith<$Res> {
  __$$PlayImplCopyWithImpl(_$PlayImpl _value, $Res Function(_$PlayImpl) _then)
      : super(_value, _then);

  /// Create a copy of SelectableRadarEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PlayImpl implements _Play {
  const _$PlayImpl();

  @override
  String toString() {
    return 'SelectableRadarEvent.play()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PlayImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(RadarEntity entity) setRadar,
    required TResult Function(RadarType type) setRadarType,
    required TResult Function() play,
    required TResult Function(int index) sliderChanged,
    required TResult Function() previous,
    required TResult Function() next,
  }) {
    return play();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(RadarEntity entity)? setRadar,
    TResult? Function(RadarType type)? setRadarType,
    TResult? Function()? play,
    TResult? Function(int index)? sliderChanged,
    TResult? Function()? previous,
    TResult? Function()? next,
  }) {
    return play?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(RadarEntity entity)? setRadar,
    TResult Function(RadarType type)? setRadarType,
    TResult Function()? play,
    TResult Function(int index)? sliderChanged,
    TResult Function()? previous,
    TResult Function()? next,
    required TResult orElse(),
  }) {
    if (play != null) {
      return play();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_SetRadar value) setRadar,
    required TResult Function(_RadarType value) setRadarType,
    required TResult Function(_Play value) play,
    required TResult Function(_SliderChanged value) sliderChanged,
    required TResult Function(_Previous value) previous,
    required TResult Function(_Next value) next,
  }) {
    return play(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_SetRadar value)? setRadar,
    TResult? Function(_RadarType value)? setRadarType,
    TResult? Function(_Play value)? play,
    TResult? Function(_SliderChanged value)? sliderChanged,
    TResult? Function(_Previous value)? previous,
    TResult? Function(_Next value)? next,
  }) {
    return play?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_SetRadar value)? setRadar,
    TResult Function(_RadarType value)? setRadarType,
    TResult Function(_Play value)? play,
    TResult Function(_SliderChanged value)? sliderChanged,
    TResult Function(_Previous value)? previous,
    TResult Function(_Next value)? next,
    required TResult orElse(),
  }) {
    if (play != null) {
      return play(this);
    }
    return orElse();
  }
}

abstract class _Play implements SelectableRadarEvent {
  const factory _Play() = _$PlayImpl;
}

/// @nodoc
abstract class _$$SliderChangedImplCopyWith<$Res> {
  factory _$$SliderChangedImplCopyWith(
          _$SliderChangedImpl value, $Res Function(_$SliderChangedImpl) then) =
      __$$SliderChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$SliderChangedImplCopyWithImpl<$Res>
    extends _$SelectableRadarEventCopyWithImpl<$Res, _$SliderChangedImpl>
    implements _$$SliderChangedImplCopyWith<$Res> {
  __$$SliderChangedImplCopyWithImpl(
      _$SliderChangedImpl _value, $Res Function(_$SliderChangedImpl) _then)
      : super(_value, _then);

  /// Create a copy of SelectableRadarEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$SliderChangedImpl(
      null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SliderChangedImpl implements _SliderChanged {
  const _$SliderChangedImpl(this.index);

  @override
  final int index;

  @override
  String toString() {
    return 'SelectableRadarEvent.sliderChanged(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SliderChangedImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  /// Create a copy of SelectableRadarEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SliderChangedImplCopyWith<_$SliderChangedImpl> get copyWith =>
      __$$SliderChangedImplCopyWithImpl<_$SliderChangedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(RadarEntity entity) setRadar,
    required TResult Function(RadarType type) setRadarType,
    required TResult Function() play,
    required TResult Function(int index) sliderChanged,
    required TResult Function() previous,
    required TResult Function() next,
  }) {
    return sliderChanged(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(RadarEntity entity)? setRadar,
    TResult? Function(RadarType type)? setRadarType,
    TResult? Function()? play,
    TResult? Function(int index)? sliderChanged,
    TResult? Function()? previous,
    TResult? Function()? next,
  }) {
    return sliderChanged?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(RadarEntity entity)? setRadar,
    TResult Function(RadarType type)? setRadarType,
    TResult Function()? play,
    TResult Function(int index)? sliderChanged,
    TResult Function()? previous,
    TResult Function()? next,
    required TResult orElse(),
  }) {
    if (sliderChanged != null) {
      return sliderChanged(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_SetRadar value) setRadar,
    required TResult Function(_RadarType value) setRadarType,
    required TResult Function(_Play value) play,
    required TResult Function(_SliderChanged value) sliderChanged,
    required TResult Function(_Previous value) previous,
    required TResult Function(_Next value) next,
  }) {
    return sliderChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_SetRadar value)? setRadar,
    TResult? Function(_RadarType value)? setRadarType,
    TResult? Function(_Play value)? play,
    TResult? Function(_SliderChanged value)? sliderChanged,
    TResult? Function(_Previous value)? previous,
    TResult? Function(_Next value)? next,
  }) {
    return sliderChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_SetRadar value)? setRadar,
    TResult Function(_RadarType value)? setRadarType,
    TResult Function(_Play value)? play,
    TResult Function(_SliderChanged value)? sliderChanged,
    TResult Function(_Previous value)? previous,
    TResult Function(_Next value)? next,
    required TResult orElse(),
  }) {
    if (sliderChanged != null) {
      return sliderChanged(this);
    }
    return orElse();
  }
}

abstract class _SliderChanged implements SelectableRadarEvent {
  const factory _SliderChanged(final int index) = _$SliderChangedImpl;

  int get index;

  /// Create a copy of SelectableRadarEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SliderChangedImplCopyWith<_$SliderChangedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PreviousImplCopyWith<$Res> {
  factory _$$PreviousImplCopyWith(
          _$PreviousImpl value, $Res Function(_$PreviousImpl) then) =
      __$$PreviousImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PreviousImplCopyWithImpl<$Res>
    extends _$SelectableRadarEventCopyWithImpl<$Res, _$PreviousImpl>
    implements _$$PreviousImplCopyWith<$Res> {
  __$$PreviousImplCopyWithImpl(
      _$PreviousImpl _value, $Res Function(_$PreviousImpl) _then)
      : super(_value, _then);

  /// Create a copy of SelectableRadarEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PreviousImpl implements _Previous {
  const _$PreviousImpl();

  @override
  String toString() {
    return 'SelectableRadarEvent.previous()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PreviousImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(RadarEntity entity) setRadar,
    required TResult Function(RadarType type) setRadarType,
    required TResult Function() play,
    required TResult Function(int index) sliderChanged,
    required TResult Function() previous,
    required TResult Function() next,
  }) {
    return previous();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(RadarEntity entity)? setRadar,
    TResult? Function(RadarType type)? setRadarType,
    TResult? Function()? play,
    TResult? Function(int index)? sliderChanged,
    TResult? Function()? previous,
    TResult? Function()? next,
  }) {
    return previous?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(RadarEntity entity)? setRadar,
    TResult Function(RadarType type)? setRadarType,
    TResult Function()? play,
    TResult Function(int index)? sliderChanged,
    TResult Function()? previous,
    TResult Function()? next,
    required TResult orElse(),
  }) {
    if (previous != null) {
      return previous();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_SetRadar value) setRadar,
    required TResult Function(_RadarType value) setRadarType,
    required TResult Function(_Play value) play,
    required TResult Function(_SliderChanged value) sliderChanged,
    required TResult Function(_Previous value) previous,
    required TResult Function(_Next value) next,
  }) {
    return previous(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_SetRadar value)? setRadar,
    TResult? Function(_RadarType value)? setRadarType,
    TResult? Function(_Play value)? play,
    TResult? Function(_SliderChanged value)? sliderChanged,
    TResult? Function(_Previous value)? previous,
    TResult? Function(_Next value)? next,
  }) {
    return previous?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_SetRadar value)? setRadar,
    TResult Function(_RadarType value)? setRadarType,
    TResult Function(_Play value)? play,
    TResult Function(_SliderChanged value)? sliderChanged,
    TResult Function(_Previous value)? previous,
    TResult Function(_Next value)? next,
    required TResult orElse(),
  }) {
    if (previous != null) {
      return previous(this);
    }
    return orElse();
  }
}

abstract class _Previous implements SelectableRadarEvent {
  const factory _Previous() = _$PreviousImpl;
}

/// @nodoc
abstract class _$$NextImplCopyWith<$Res> {
  factory _$$NextImplCopyWith(
          _$NextImpl value, $Res Function(_$NextImpl) then) =
      __$$NextImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NextImplCopyWithImpl<$Res>
    extends _$SelectableRadarEventCopyWithImpl<$Res, _$NextImpl>
    implements _$$NextImplCopyWith<$Res> {
  __$$NextImplCopyWithImpl(_$NextImpl _value, $Res Function(_$NextImpl) _then)
      : super(_value, _then);

  /// Create a copy of SelectableRadarEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$NextImpl implements _Next {
  const _$NextImpl();

  @override
  String toString() {
    return 'SelectableRadarEvent.next()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NextImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(RadarEntity entity) setRadar,
    required TResult Function(RadarType type) setRadarType,
    required TResult Function() play,
    required TResult Function(int index) sliderChanged,
    required TResult Function() previous,
    required TResult Function() next,
  }) {
    return next();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(RadarEntity entity)? setRadar,
    TResult? Function(RadarType type)? setRadarType,
    TResult? Function()? play,
    TResult? Function(int index)? sliderChanged,
    TResult? Function()? previous,
    TResult? Function()? next,
  }) {
    return next?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(RadarEntity entity)? setRadar,
    TResult Function(RadarType type)? setRadarType,
    TResult Function()? play,
    TResult Function(int index)? sliderChanged,
    TResult Function()? previous,
    TResult Function()? next,
    required TResult orElse(),
  }) {
    if (next != null) {
      return next();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_SetRadar value) setRadar,
    required TResult Function(_RadarType value) setRadarType,
    required TResult Function(_Play value) play,
    required TResult Function(_SliderChanged value) sliderChanged,
    required TResult Function(_Previous value) previous,
    required TResult Function(_Next value) next,
  }) {
    return next(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_SetRadar value)? setRadar,
    TResult? Function(_RadarType value)? setRadarType,
    TResult? Function(_Play value)? play,
    TResult? Function(_SliderChanged value)? sliderChanged,
    TResult? Function(_Previous value)? previous,
    TResult? Function(_Next value)? next,
  }) {
    return next?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_SetRadar value)? setRadar,
    TResult Function(_RadarType value)? setRadarType,
    TResult Function(_Play value)? play,
    TResult Function(_SliderChanged value)? sliderChanged,
    TResult Function(_Previous value)? previous,
    TResult Function(_Next value)? next,
    required TResult orElse(),
  }) {
    if (next != null) {
      return next(this);
    }
    return orElse();
  }
}

abstract class _Next implements SelectableRadarEvent {
  const factory _Next() = _$NextImpl;
}

/// @nodoc
mixin _$SelectableRadarState {
  BlocState get status => throw _privateConstructorUsedError;
  RadarEntity? get selectedRadar => throw _privateConstructorUsedError;
  List<RadarImageEntity>? get radarImages => throw _privateConstructorUsedError;
  RadarImageEntity? get selectedRadarImages =>
      throw _privateConstructorUsedError;
  bool get isPlaying => throw _privateConstructorUsedError;
  bool get dirRight => throw _privateConstructorUsedError;
  RadarType get type => throw _privateConstructorUsedError;
  int get currentIndex => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            BlocState status,
            RadarEntity? selectedRadar,
            List<RadarImageEntity>? radarImages,
            RadarImageEntity? selectedRadarImages,
            bool isPlaying,
            bool dirRight,
            RadarType type,
            int currentIndex,
            String? message)
        initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            BlocState status,
            RadarEntity? selectedRadar,
            List<RadarImageEntity>? radarImages,
            RadarImageEntity? selectedRadarImages,
            bool isPlaying,
            bool dirRight,
            RadarType type,
            int currentIndex,
            String? message)?
        initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            BlocState status,
            RadarEntity? selectedRadar,
            List<RadarImageEntity>? radarImages,
            RadarImageEntity? selectedRadarImages,
            bool isPlaying,
            bool dirRight,
            RadarType type,
            int currentIndex,
            String? message)?
        initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Create a copy of SelectableRadarState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SelectableRadarStateCopyWith<SelectableRadarState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SelectableRadarStateCopyWith<$Res> {
  factory $SelectableRadarStateCopyWith(SelectableRadarState value,
          $Res Function(SelectableRadarState) then) =
      _$SelectableRadarStateCopyWithImpl<$Res, SelectableRadarState>;
  @useResult
  $Res call(
      {BlocState status,
      RadarEntity? selectedRadar,
      List<RadarImageEntity>? radarImages,
      RadarImageEntity? selectedRadarImages,
      bool isPlaying,
      bool dirRight,
      RadarType type,
      int currentIndex,
      String? message});
}

/// @nodoc
class _$SelectableRadarStateCopyWithImpl<$Res,
        $Val extends SelectableRadarState>
    implements $SelectableRadarStateCopyWith<$Res> {
  _$SelectableRadarStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SelectableRadarState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? selectedRadar = freezed,
    Object? radarImages = freezed,
    Object? selectedRadarImages = freezed,
    Object? isPlaying = null,
    Object? dirRight = null,
    Object? type = null,
    Object? currentIndex = null,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as BlocState,
      selectedRadar: freezed == selectedRadar
          ? _value.selectedRadar
          : selectedRadar // ignore: cast_nullable_to_non_nullable
              as RadarEntity?,
      radarImages: freezed == radarImages
          ? _value.radarImages
          : radarImages // ignore: cast_nullable_to_non_nullable
              as List<RadarImageEntity>?,
      selectedRadarImages: freezed == selectedRadarImages
          ? _value.selectedRadarImages
          : selectedRadarImages // ignore: cast_nullable_to_non_nullable
              as RadarImageEntity?,
      isPlaying: null == isPlaying
          ? _value.isPlaying
          : isPlaying // ignore: cast_nullable_to_non_nullable
              as bool,
      dirRight: null == dirRight
          ? _value.dirRight
          : dirRight // ignore: cast_nullable_to_non_nullable
              as bool,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RadarType,
      currentIndex: null == currentIndex
          ? _value.currentIndex
          : currentIndex // ignore: cast_nullable_to_non_nullable
              as int,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res>
    implements $SelectableRadarStateCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {BlocState status,
      RadarEntity? selectedRadar,
      List<RadarImageEntity>? radarImages,
      RadarImageEntity? selectedRadarImages,
      bool isPlaying,
      bool dirRight,
      RadarType type,
      int currentIndex,
      String? message});
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$SelectableRadarStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of SelectableRadarState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? selectedRadar = freezed,
    Object? radarImages = freezed,
    Object? selectedRadarImages = freezed,
    Object? isPlaying = null,
    Object? dirRight = null,
    Object? type = null,
    Object? currentIndex = null,
    Object? message = freezed,
  }) {
    return _then(_$InitialImpl(
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as BlocState,
      selectedRadar: freezed == selectedRadar
          ? _value.selectedRadar
          : selectedRadar // ignore: cast_nullable_to_non_nullable
              as RadarEntity?,
      radarImages: freezed == radarImages
          ? _value._radarImages
          : radarImages // ignore: cast_nullable_to_non_nullable
              as List<RadarImageEntity>?,
      selectedRadarImages: freezed == selectedRadarImages
          ? _value.selectedRadarImages
          : selectedRadarImages // ignore: cast_nullable_to_non_nullable
              as RadarImageEntity?,
      isPlaying: null == isPlaying
          ? _value.isPlaying
          : isPlaying // ignore: cast_nullable_to_non_nullable
              as bool,
      dirRight: null == dirRight
          ? _value.dirRight
          : dirRight // ignore: cast_nullable_to_non_nullable
              as bool,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as RadarType,
      currentIndex: null == currentIndex
          ? _value.currentIndex
          : currentIndex // ignore: cast_nullable_to_non_nullable
              as int,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl(
      {this.status = BlocState.initial,
      this.selectedRadar,
      final List<RadarImageEntity>? radarImages,
      this.selectedRadarImages,
      this.isPlaying = false,
      this.dirRight = true,
      this.type = RadarType.cmax,
      this.currentIndex = 0,
      this.message})
      : _radarImages = radarImages;

  @override
  @JsonKey()
  final BlocState status;
  @override
  final RadarEntity? selectedRadar;
  final List<RadarImageEntity>? _radarImages;
  @override
  List<RadarImageEntity>? get radarImages {
    final value = _radarImages;
    if (value == null) return null;
    if (_radarImages is EqualUnmodifiableListView) return _radarImages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final RadarImageEntity? selectedRadarImages;
  @override
  @JsonKey()
  final bool isPlaying;
  @override
  @JsonKey()
  final bool dirRight;
  @override
  @JsonKey()
  final RadarType type;
  @override
  @JsonKey()
  final int currentIndex;
  @override
  final String? message;

  @override
  String toString() {
    return 'SelectableRadarState.initial(status: $status, selectedRadar: $selectedRadar, radarImages: $radarImages, selectedRadarImages: $selectedRadarImages, isPlaying: $isPlaying, dirRight: $dirRight, type: $type, currentIndex: $currentIndex, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InitialImpl &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.selectedRadar, selectedRadar) ||
                other.selectedRadar == selectedRadar) &&
            const DeepCollectionEquality()
                .equals(other._radarImages, _radarImages) &&
            (identical(other.selectedRadarImages, selectedRadarImages) ||
                other.selectedRadarImages == selectedRadarImages) &&
            (identical(other.isPlaying, isPlaying) ||
                other.isPlaying == isPlaying) &&
            (identical(other.dirRight, dirRight) ||
                other.dirRight == dirRight) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.currentIndex, currentIndex) ||
                other.currentIndex == currentIndex) &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      status,
      selectedRadar,
      const DeepCollectionEquality().hash(_radarImages),
      selectedRadarImages,
      isPlaying,
      dirRight,
      type,
      currentIndex,
      message);

  /// Create a copy of SelectableRadarState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      __$$InitialImplCopyWithImpl<_$InitialImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            BlocState status,
            RadarEntity? selectedRadar,
            List<RadarImageEntity>? radarImages,
            RadarImageEntity? selectedRadarImages,
            bool isPlaying,
            bool dirRight,
            RadarType type,
            int currentIndex,
            String? message)
        initial,
  }) {
    return initial(status, selectedRadar, radarImages, selectedRadarImages,
        isPlaying, dirRight, type, currentIndex, message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            BlocState status,
            RadarEntity? selectedRadar,
            List<RadarImageEntity>? radarImages,
            RadarImageEntity? selectedRadarImages,
            bool isPlaying,
            bool dirRight,
            RadarType type,
            int currentIndex,
            String? message)?
        initial,
  }) {
    return initial?.call(status, selectedRadar, radarImages,
        selectedRadarImages, isPlaying, dirRight, type, currentIndex, message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            BlocState status,
            RadarEntity? selectedRadar,
            List<RadarImageEntity>? radarImages,
            RadarImageEntity? selectedRadarImages,
            bool isPlaying,
            bool dirRight,
            RadarType type,
            int currentIndex,
            String? message)?
        initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(status, selectedRadar, radarImages, selectedRadarImages,
          isPlaying, dirRight, type, currentIndex, message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements SelectableRadarState {
  const factory _Initial(
      {final BlocState status,
      final RadarEntity? selectedRadar,
      final List<RadarImageEntity>? radarImages,
      final RadarImageEntity? selectedRadarImages,
      final bool isPlaying,
      final bool dirRight,
      final RadarType type,
      final int currentIndex,
      final String? message}) = _$InitialImpl;

  @override
  BlocState get status;
  @override
  RadarEntity? get selectedRadar;
  @override
  List<RadarImageEntity>? get radarImages;
  @override
  RadarImageEntity? get selectedRadarImages;
  @override
  bool get isPlaying;
  @override
  bool get dirRight;
  @override
  RadarType get type;
  @override
  int get currentIndex;
  @override
  String? get message;

  /// Create a copy of SelectableRadarState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
